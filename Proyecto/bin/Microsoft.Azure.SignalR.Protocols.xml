<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Azure.SignalR.Protocols</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckWithAckMessage">
            <summary>
            Base class of check-with-ack messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage">
            <summary>
            A waiting for ack check-user-in-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name to check whether the user is in or not.</param>
            <param name="ackId">The ack Id.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage">
            <summary>
            A waiting for ack check-any-connection-in-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage.#ctor(System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage"/> class.
            </summary>
            <param name="groupName">The group name.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage">
            <summary>
            A waiting for ack check-connection-existence message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage.#ctor(System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage">
            <summary>
            A waiting for ack check-user-existence message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage.#ctor(System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseWithAckMessage.AckId">
            <summary>
            Gets or sets the ack Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseWithAckMessage.Reason">
            <summary>
            Gets or sets the reason for the close.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseMultiConnectionsWithAckMessage.ExcludedList">
            <summary>
            Gets or sets the list of excluded connection Ids.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage">
            <summary>
            A close-connection message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id for the connection.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionsWithAckMessage">
            <summary>
            Close all the connections in the hub.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionsWithAckMessage.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionsWithAckMessage"/> class.
            </summary>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage">
            <summary>
            Close connections for a user.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage"/> class.
            </summary>
            <param name="userId">The user Id for the message.</param>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage">
            <summary>
            Close connections in a group.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage"/> class.
            </summary>
            <param name="groupName">The group name for the message.</param>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ConnectionMessage">
            <summary>
            Base class of connection-specific messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage">
            <summary>
            A open-connection message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.#ctor(System.String,System.Security.Claims.Claim[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="claims">An array of <see cref="T:System.Security.Claims.Claim"/> associated with the connection.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.#ctor(System.String,System.Security.Claims.Claim[],System.Collections.Generic.IDictionary{System.String,Microsoft.Extensions.Primitives.StringValues},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="claims">An array of <see cref="T:System.Security.Claims.Claim"/> associated with the connection.</param>
            <param name="headers">A <see cref="T:System.Collections.Generic.IDictionary`2"/> associated with the connection.</param>
            <param name="queryString">Query string associated with the connection.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.Claims">
            <summary>
            Gets or sets the associated claims.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.Headers">
            <summary>
            Gets or sets the associated headers.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.QueryString">
            <summary>
            Gets or sets the associated query string.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.Protocol">
            <summary>
            Gets or sets the protocol for new connection.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage">
            <summary>
            A close-connection message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Extensions.Primitives.StringValues})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="errorMessage">Optional error message.</param>
            <param name="headers">A <see cref="T:System.Collections.Generic.IDictionary`2"/> associated with the connection.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.#ctor(System.String)">
            <summary>
            Test only
            </summary>
            <param name="connectionId"></param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.ErrorMessage">
            <summary>
            Gets or sets the error message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.Headers">
            <summary>
            Gets or sets the associated headers.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage">
            <summary>
            A connection data message.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.#ctor(System.String,System.ReadOnlyMemory{System.Byte},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="payload">Binary data to be delivered.</param>
            <param name="tracingId">The tracing Id of the message</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.#ctor(System.String,System.Buffers.ReadOnlySequence{System.Byte},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="payload">Binary data to be delivered.</param>
            <param name="tracingId">The tracing Id of the message</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.Payload">
            <summary>
            Gets or sets the binary payload.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.TracingId">
            <summary>
            Gets or sets the message ID
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage">
            <summary>
            Base class of client invocation completion messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage.InvocationId">
            <summary>
            Gets or sets the client invocation Id of pending connection.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage.CallerServerId">
            <summary>
            Gets or sets the server Id which parse the completion message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage.TracingId">
            <summary>
            Gets or sets the message ID
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage">
            <summary>
            A data message of client invocation completion result.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage.#ctor(System.String,System.String,System.String,System.String,System.ReadOnlyMemory{System.Byte},System.Nullable{System.UInt64})">
            <summary>
            Initialize a new instance of <see cref="T:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage"/> class.
            </summary>
            <param name="invocationId">The Id of the invocation that has completed.</param>
            <param name="connectionId">The client connection Id that complete the invocation.</param>
            <param name="callerServerId">The serverId that wrap the completion result.</param>
            <param name="protocol">The protocol of the connection.</param>
            <param name="payload">The payload of the completion result.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage.Protocol">
            <summary>
            Gets or sets the connection protocol.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage.Payload">
            <summary>
            Gets or sets the binary payload.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ErrorCompletionMessage">
            <summary>
            An error response indicates client invocation failed with details.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ErrorCompletionMessage.#ctor(System.String,System.String,System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initialize a new instance of <see cref="T:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage"/> class with error information.
            </summary>
            <param name="invocationId">The Id of the invocation that has completed.</param>
            <param name="connectionId">The client connection Id that complete the invocation.</param>
            <param name="callerServerId">The serverId that wrap the completion result.</param>
            <param name="error">The error information about invacation failure.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ErrorCompletionMessage.Error">
            <summary>
            Gets or sets the error message.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType">
            <summary>
            The type of service event object.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.ServiceInstance">
            <summary>
            The instance of service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.Connection">
            <summary>
            The connection.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.User">
            <summary>
            The user.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.Group">
            <summary>
            The group.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.ServerConnection">
            <summary>
            The server connection.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceEventKind">
            <summary>
            The kind of service event.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.Reloading">
            <summary>
            The reloading event.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.Invalid">
            <summary>
            The format of id is invalid.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.NotExisted">
            <summary>
            The id is not existed.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.BufferFull">
            <summary>
            The buffer-full event. When the server is sending too many messages at the same time, the service would back-pressure the messages to the server-side and also trigger this `BufferFull` event.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage">
            <summary>
            A join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, to which the connection will join.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage">
            <summary>
            A leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, from which the connection will leave.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage">
            <summary>
            A user-join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.Ttl">
            <summary>
            Time to live for the user in the group.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, to which the user will join.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage">
            <summary>
            A user-leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, from which the user will leave.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage">
            <summary>
            A waiting for ack user-join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.Ttl">
            <summary>
            Time to live for the user in the group.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, to which the user will join.</param>
            <param name="ackId">The ack Id.</param>
            <param name="ttl">Time to live for the user in the group.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage">
            <summary>
            A waiting for ack  user-leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, from which the user will leave.</param>
            <param name="ackId">The ack Id.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage">
            <summary>
            A waiting for ack join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, to which the connection will join.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, to which the connection will join.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage">
            <summary>
            A waiting for ack leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, from which the connection will leave.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, from which the connection will leave.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.IServiceProtocol">
            <summary>
            A protocol abstraction for communication between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.Version">
            <summary>
            Gets the version of the protocol.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.TryParseMessage(System.Buffers.ReadOnlySequence{System.Byte}@,Microsoft.Azure.SignalR.Protocol.ServiceMessage@)">
            <summary>
            Creates a new <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> from the specified serialized representation.
            </summary>
            <param name="input">The serialized representation of the message.</param>
            <param name="message">When this method returns <c>true</c>, contains the parsed message.</param>
            <returns>A value that is <c>true</c> if the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> was successfully parsed; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.WriteMessage(Microsoft.Azure.SignalR.Protocol.ServiceMessage,System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Writes the specified <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> to a writer.
            </summary>
            <param name="message">The message to write.</param>
            <param name="output">The output writer.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.GetMessageBytes(Microsoft.Azure.SignalR.Protocol.ServiceMessage)">
            <summary>
            Converts the specified <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> to its serialized representation.
            </summary>
            <param name="message">The message to convert.</param>
            <returns>The serialized representation of the message.</returns>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MulticastDataMessage">
            <summary>
            Base class for multicast data messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MulticastDataMessage.Payloads">
            <summary>
            Gets or sets the payload dictionary which contains binary payload of multiple protocols.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MulticastDataMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage">
            <summary>
            A data message which will be sent to multiple connections.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage"/> class.
            </summary>
            <param name="connectionList">The list of connection Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage.ConnectionList">
            <summary>
            Gets or sets the list of connections which will receive this message.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserDataMessage">
            <summary>
            A data message which will be sent to a user.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserDataMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserDataMessage.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserDataMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage">
            <summary>
            A data message which will be sent to multiple users.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage"/> class.
            </summary>
            <param name="userList">The list of user Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage.UserList">
            <summary>
            Gets or sets the list of user Ids.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage">
            <summary>
            A data message which will be broadcasted.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage.ExcludedList">
            <summary>
            Gets or sets the list of excluded connection Ids.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage.#ctor(System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage"/> class.
            </summary>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage"/> class.
            </summary>
            <param name="excludedList">The list of excluded connection Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage">
            <summary>
            A data message which will be broadcasted within a group.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.ExcludedList">
            <summary>
            Gets or sets the list of excluded connection Ids.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.ExcludedUserList">
            <summary>
            Gets or sets the list of excluded user Ids.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.CallerUserId">
            <summary>
            Gets or sets the user ID of the message caller
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage"/> class.
            </summary>
            <param name="groupName">The group name.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.#ctor(System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage"/> class.
            </summary>
            <param name="groupName">The group name.</param>
            <param name="excludedList">The list of excluded connection Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage">
            <summary>
            A data message which will be broadcasted within multiple groups.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage.GroupList">
            <summary>
            Gets or sets the list of group names.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage"/> class.
            </summary>
            <param name="groupList">The list of group names.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage">
            <summary>
            A data message to indicate a client invocation request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.#ctor(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initialize a new instance of <see cref="T:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage"/> class.
            </summary>
            <param name="invocationId">The Id of the client invocation request.</param>
            <param name="connectionId">The client connection Id.</param>
            <param name="callerServerId">The serverId that init the client invocation.</param>
            <param name="payloads">The payload of the message.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.InvocationId">
            <summary>
            Gets or sets the Id of the client invocation request.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.ConnectionId">
            <summary>
            Gets or sets the client connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.CallerServerId">
            <summary>
            Gets or sets the caller server Id that init the client invocation.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage">
            <summary>
            Base class of messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceMessage.Clone">
            <summary>
            Clone should make a copy of everything that may get modified throughout the lifetime of the message
            The default implementation is a shallow copy as it fits the current needs.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ExtensibleServiceMessage">
            <summary>
            Base class of messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.IAckableMessage">
            <summary>
            Interface of ack-able message 
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage">
            <summary>
            An access key request message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.Token">
            <summary>
            Gets or sets the Azure Active Directory token.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.Kid">
            <summary>
            Gets or sets the key Id.
            <c>null</c> 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage"/> class.
            </summary>
            <param name="token"></param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage">
            <summary>
            An access key response message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.Kid">
            <summary>
            Gets or sets the key Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.AccessKey">
            <summary>
            Gets or sets the access key.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.ErrorType">
            <summary>
            Gets or sets error type.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.ErrorMessage">
            <summary>
            Gets or sets error message.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage"/> class.
            </summary>
            <param name="kid"></param>
            <param name="key"></param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage"/> class.
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage">
            <summary>
            A handshake request message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.Version">
            <summary>
            Gets or sets the requested protocol version.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.ConnectionType">
            <summary>
            Gets or sets the type of service connection.
            </summary>
            <value>
            <list type="bullet">
            <item>0, Default, it can carry clients, service runtime should always accept this kind of connection.</item>
            <item>1, OnDemand, creating when service requested more connections, it can carry clients, but it may be rejected by service runtime.</item>
            <item>2, Weak, it can not carry clients, but it can send message.</item>
            </list>
            </value>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.Target">
            <summary>
            Gets or sets the target of service connection, only work for OnDemand connections.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.MigrationLevel">
            <summary>
            Gets or sets the migratable flag.
            <value>
            <list type="bullet">
            <item>0, Off, a client connection can not be migrated to another server.</item>
            <item>1, ShutdownOnly, a client connection can be migrated only if the pairing server was shutdown gracefully.</item>
            <item>2, Any, a client connection can be migrated even if the pairing server connection was dropped accidentally. (may cause data loss)</item>
            </list>
            </value>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage"/> class.
            </summary>
            <param name="version">version</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage"/> class.
            </summary>
            <param name="version">version</param>
            <param name="connectionType">connection type</param>
            <param name="migrationLevel">migration level</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage">
            <summary>
            A handshake response message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage.ErrorMessage">
            <summary>
            Gets or sets the optional error message.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage"/> class.
            </summary>
            <param name="errorMessage">An optional response error message. A <c>null</c> or empty error message indicates a successful handshake.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.PingMessage">
            <summary>
            A ping message.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.PingMessage.Instance">
            <summary>
            A static ping message.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage">
            <summary>
            A service error message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage.ErrorMessage">
            <summary>
            Gets or sets the error message
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage"/> class.
            </summary>
            <param name="errorMessage">An error message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage">
            <summary>
            A service warning message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Type">
            <summary>
            Gets or sets the type of event object.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Id">
            <summary>
            Gets or sets the id of event object.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Kind">
            <summary>
            Gets or sets the kind of event.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Message">
            <summary>
            Gets or sets the message of event.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.#ctor(Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType,System.String,Microsoft.Azure.SignalR.Protocol.ServiceEventKind,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage"/> class.
            </summary>
            <param name="type">A type of event object.</param>
            <param name="id">An id of event object.</param>
            <param name="kind">A kind of event.</param>
            <param name="message">A message of event.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.AckMessage">
            <summary>
            An ack message to response ack-able message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AckMessage.Status">
            <summary>
            Gets or sets the status code
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AckMessage.Message">
            <summary>
            Gets or sets the ack message
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AckMessage.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AckMessage"/> class.
            </summary>
            <param name="ackId">The ack Id</param>
            <param name="status">The status code</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AckMessage.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AckMessage"/> class.
            </summary>
            <param name="ackId">The ack Id</param>
            <param name="status">The status code</param>
            <param name="message">The ack message</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage">
            <summary>
            A message indicates the mapping of client invocation with service instance.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.InvocationId">
            <summary>
            Gets or sets the invocation Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.InstanceId">
            <summary>
            Gets or set the service instance Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage"/> class.
            </summary>
            <param name="invocationId">The invocation Id.</param>
            <param name="connectionId">The connection Id.</param>
            <param name="instanceId">The service instance Id.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceProtocol">
            <summary>
            Implements the Azure SignalR Service Protocol.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.Version">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.TryParseMessage(System.Buffers.ReadOnlySequence{System.Byte}@,Microsoft.Azure.SignalR.Protocol.ServiceMessage@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.WriteMessage(Microsoft.Azure.SignalR.Protocol.ServiceMessage,System.Buffers.IBufferWriter{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.GetMessageBytes(Microsoft.Azure.SignalR.Protocol.ServiceMessage)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.SignalR.MemoryBufferWriter.CompletedBuffer">
            <summary>
            Holds a byte[] from the pool and a size value. Basically a Memory but guaranteed to be backed by an ArrayPool byte[], so that we know we can return it.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackReader">
            <summary>
            A primitive types reader for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when reading methods fail due to invalid data.</exception>
            <exception cref="T:System.IO.EndOfStreamException">Thrown by reading methods when there are not enough bytes to read the required value.</exception>
        </member>
        <member name="F:MessagePack.MessagePackReader.reader">
            <summary>
            The reader over the sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="memory">The buffer to read from.</param>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
        </member>
        <member name="P:MessagePack.MessagePackReader.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this deserialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Depth">
            <summary>
            Gets or sets the present depth of the object graph being deserialized.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Sequence">
            <summary>
            Gets the <see cref="T:System.Buffers.ReadOnlySequence`1"/> originally supplied to the constructor.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Position">
            <summary>
            Gets the current position of the reader within <see cref="P:MessagePack.MessagePackReader.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Consumed">
            <summary>
            Gets the number of bytes consumed by the reader.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.End">
            <summary>
            Gets a value indicating whether the reader is at the end of the sequence.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.IsNil">
            <summary>
            Gets a value indicating whether the reader position is pointing at a nil value.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextMessagePackType">
            <summary>
            Gets the next message pack type to be read.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextCode">
            <summary>
            Gets the type of the next MessagePack block.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
            <remarks>
            See <see cref="T:MessagePack.MessagePackCode"/> for valid message pack codes and ranges.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Clone(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct,
            with the same settings as this one, but with its own buffer to read from.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
            <returns>The new reader.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.CreatePeekReader">
            <summary>
            Creates a new <see cref="T:MessagePack.MessagePackReader"/> at this reader's current position.
            The two readers may then be used independently without impacting each other.
            </summary>
            <returns>A new <see cref="T:MessagePack.MessagePackReader"/>.</returns>
            <devremarks>
            Since this is a struct, copying it completely is as simple as returning itself
            from a property that isn't a "ref return" property.
            </devremarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Skip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.TrySkip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <returns><c>true</c> if the entire structure beginning at the current <see cref="P:MessagePack.MessagePackReader.Position"/> is found in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>; <c>false</c> otherwise.</returns>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadNil">
            <summary>
            Reads a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
            <returns>A nil value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadNil">
            <summary>
            Reads nil if it is the next token.
            </summary>
            <returns><c>true</c> if the next token was nil; <c>false</c> otherwise.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw(System.Int64)">
            <summary>
            Reads a sequence of bytes without any decoding.
            </summary>
            <param name="length">The number of bytes to read.</param>
            <returns>The sequence of bytes read.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw">
            <summary>
            Reads the next MessagePack primitive.
            </summary>
            <returns>The raw MessagePack sequence.</returns>
            <remarks>
            The entire primitive is read, including content of maps or arrays, or any other type with payloads.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadArrayHeader">
            <summary>
            Read an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadArrayHeader(System.Int32@)">
            <summary>
            Reads an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of elements in the array if the entire array header could be read.</param>
            <returns><c>true</c> if there was sufficient buffer and an array header was found; <c>false</c> if the buffer incompletely describes an array header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
            <remarks>
            When this method returns <c>false</c> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadMapHeader">
            <summary>
            Read a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>.
            </summary>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadMapHeader(System.Int32@)">
            <summary>
            Reads a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of key=value pairs in the map if the entire map header can be read.</param>
            <returns><c>true</c> if there was sufficient buffer and a map header was found; <c>false</c> if the buffer incompletely describes an map header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
            <remarks>
            When this method returns <c>false</c> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBoolean">
            <summary>
            Reads a boolean value from either a <see cref="F:MessagePack.MessagePackCode.False"/> or <see cref="F:MessagePack.MessagePackCode.True"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadChar">
            <summary>
            Reads a <see cref="T:System.Char"/> from any of:
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            or anything between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>A character.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSingle">
            <summary>
            Reads an <see cref="T:System.Single"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDouble">
            <summary>
            Reads an <see cref="T:System.Double"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float64"/>,
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime(MessagePack.ExtensionHeader)">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="header">The extension header that was already read.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBytes">
            <summary>
            Reads a span of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or to support OldSpec compatibility:
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or something beteween <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            A sequence of bytes, or <c>null</c> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSequence">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            The sequence of bytes, or <c>null</c> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadStringSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <param name="span">Receives the span to the string.</param>
            <returns>
            <c>true</c> if the string is contiguous in memory such that it could be set as a single span.
            <c>false</c> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/> or the string is not in a contiguous span.
            </returns>
            <remarks>
            Callers should generally be prepared for a <c>false</c> result and failover to calling <see cref="M:MessagePack.MessagePackReader.ReadStringSequence"/>
            which can represent a <c>null</c> result and handle strings that are not contiguous in memory.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadString">
            <summary>
            Reads a string, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>A string, or <c>null</c> if the current msgpack token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormatHeader">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>The extension header.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the bytes the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadExtensionFormatHeader(MessagePack.ExtensionHeader@)">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="extensionHeader">Receives the extension header if the remaining bytes in the <see cref="P:MessagePack.MessagePackReader.Sequence"/> fully describe the header.</param>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
            <remarks>
            When this method returns <c>false</c> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormat">
            <summary>
            Reads an extension format header and data, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>
            The extension format.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException(System.Exception)">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInvalidCode(System.Byte)">
            <summary>
            Throws an <see cref="T:MessagePack.MessagePackSerializationException"/> explaining an unexpected code was encountered.
            </summary>
            <param name="code">The code that was encountered.</param>
            <returns>Nothing. This method always throws.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInsufficientBufferUnless(System.Boolean)">
            <summary>
            Throws <see cref="T:System.IO.EndOfStreamException"/> if a condition is false.
            </summary>
            <param name="condition">A boolean value.</param>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if <paramref name="condition"/> is <c>false</c>.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.GetStringLengthInBytes">
            <summary>
            Gets the length of the next string.
            </summary>
            <returns>The length of the next string.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSlow(System.Int32)">
            <summary>
            Reads a string assuming that it is spread across multiple spans in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="byteLength">The length of the string to be decoded, in bytes.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadByte">
            <summary>
            Reads an <see cref="T:System.Byte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt16">
            <summary>
            Reads an <see cref="T:System.UInt16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt32">
            <summary>
            Reads an <see cref="T:System.UInt32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt64">
            <summary>
            Reads an <see cref="T:System.UInt64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSByte">
            <summary>
            Reads an <see cref="T:System.SByte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt16">
            <summary>
            Reads an <see cref="T:System.Int16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt32">
            <summary>
            Reads an <see cref="T:System.Int32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt64">
            <summary>
            Reads an <see cref="T:System.Int64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="T:MessagePack.MessagePackSerializationException">
            <summary>
            An exception thrown during serializing an object graph or deserializing a messagepack sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Serialization context.</param>
        </member>
        <member name="T:MessagePack.MessagePackType">
            <summary>
            https://github.com/msgpack/msgpack/blob/master/spec.md#serialization-type-to-format-conversion.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackCode">
            <summary>
            The core type codes as defined by msgpack.
            </summary>
            <seealso href="https://github.com/msgpack/msgpack/blob/master/spec.md#overview" />
        </member>
        <member name="M:MessagePack.MessagePackCode.IsSignedInteger(System.Byte)">
            <summary>
            Checks whether a given messagepack code represents an integer that might include a sign (i.e. might be a negative number).
            </summary>
            <param name="code">The messagepack code.</param>
            <returns>A boolean value.</returns>
        </member>
        <member name="T:MessagePack.ReservedMessagePackExtensionTypeCode">
            <summary>
            The officially defined messagepack extension type codes.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackWriter">
            <summary>
            A primitive types writer for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
        </member>
        <member name="F:MessagePack.MessagePackWriter.writer">
            <summary>
            The writer to use.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="writer">The writer to use.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.MessagePackWriter.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this serialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackWriter.OldSpec">
            <summary>
            Gets or sets a value indicating whether to write in <see href="https://github.com/msgpack/msgpack/blob/master/spec-old.md">old spec</see> compatibility mode.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Clone(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct,
            with the same settings as this one, but with its own buffer writer.
            </summary>
            <param name="writer">The writer to use for the new instance.</param>
            <returns>The new writer.</returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Flush">
            <summary>
            Ensures everything previously written has been flushed to the underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteNil">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.Int32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.UInt32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.Int32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.UInt32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt8(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.SByte)">
            <summary>
            Writes an 8-bit value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt8(System.SByte)">
            <summary>
            Writes an 8-bit value using <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>, or
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int64)">
            <summary>
            Writes an <see cref="T:System.Int64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> using <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value using either <see cref="F:MessagePack.MessagePackCode.True"/> or <see cref="F:MessagePack.MessagePackCode.False"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Single)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float32"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Double)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float64"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> using the message code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="dateTime">The value to write.</param>
            <exception cref="T:System.NotSupportedException">Thrown when <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is true because the old spec does not define a <see cref="T:System.DateTime"/> format.</exception>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte"/>[], prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if <paramref name="src"/> is <c>null</c>.
            </summary>
            <param name="src">The array of bytes to write. May be <c>null</c>.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a span of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <c>true</c>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes a sequence of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <c>true</c>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBinHeader(System.Int32)">
            <summary>
            Writes the header that precedes a raw binary sequence with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="length">The length of bytes that will be written next.</param>
            <remarks>
            <para>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </para>
            <para>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <c>true</c>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </para>
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteStringHeader(System.Int32)">
            <summary>
            Writes out the header that may precede a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="byteCount">The number of bytes in the string that will follow this header.</param>
            <remarks>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.String)">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if the <paramref name="value"/> is <c>null</c>.
            </summary>
            <param name="value">The value to write. May be null.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Char})">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormatHeader(MessagePack.ExtensionHeader)">
            <summary>
            Writes the extension format header, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionHeader">The extension header.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormat(MessagePack.ExtensionResult)">
            <summary>
            Writes an extension format, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionData">The extension data.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)">
            <summary>
            Gets memory where raw messagepack data can be written.
            </summary>
            <param name="length">The size of the memory block required.</param>
            <returns>The span of memory to write to. This *may* exceed <paramref name="length"/>.</returns>
            <remarks>
            <para>After initializing the resulting memory, always follow up with a call to <see cref="M:MessagePack.MessagePackWriter.Advance(System.Int32)"/>.</para>
            <para>
            This is similar in purpose to <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            but provides uninitialized memory for the caller to write to instead of copying initialized memory from elsewhere.
            </para>
            </remarks>
            <seealso cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Advance(System.Int32)">
            <summary>
            Commits memory previously returned from <see cref="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)"/> as initialized.
            </summary>
            <param name="length">The number of bytes initialized with messagepack data from the previously returned span.</param>
            <seealso cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt16)">
            <summary>
            Writes a 16-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt32)">
            <summary>
            Writes a 32-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt64)">
            <summary>
            Writes a 64-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Estimates the length of the header required for a given string.
            </summary>
            <param name="characterLength">The length of the string to be written, in characters.</param>
            <param name="bufferSize">Receives the guaranteed length of the returned buffer.</param>
            <param name="encodedBytesOffset">Receives the offset within the returned buffer to write the encoded string to.</param>
            <returns>
            A reference to the first byte in the buffer.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PostEncoding(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Finalizes an encoding of a string.
            </summary>
            <param name="pBuffer">A pointer obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="estimatedOffset">The offset obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="byteCount">The number of bytes used to actually encode the string.</param>
        </member>
        <member name="T:MessagePack.BufferWriter">
            <summary>
            A fast access struct that wraps <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._output">
            <summary>
            The underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._span">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            Backing field for the <see cref="P:MessagePack.BufferWriter.Span"/> property.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._segment">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._buffered">
            <summary>
            The number of uncommitted bytes (all the calls to <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> since the last call to <see cref="M:MessagePack.BufferWriter.Commit"/>).
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._bytesCommitted">
            <summary>
            The total number of bytes written with this writer.
            Backing field for the <see cref="P:MessagePack.BufferWriter.BytesCommitted"/> property.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="output">The <see cref="T:System.Buffers.IBufferWriter`1"/> to be wrapped.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.BufferWriter.Span">
            <summary>
            Gets the result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.BytesCommitted">
            <summary>
            Gets the total number of bytes written with this writer.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.UnderlyingWriter">
            <summary>
            Gets the <see cref="T:System.Buffers.IBufferWriter`1"/> underlying this instance.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Commit">
            <summary>
            Calls <see cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/> on the underlying writer
            with the number of uncommitted bytes.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Advance(System.Int32)">
            <summary>
            Used to indicate that part of the buffer has been written to.
            </summary>
            <param name="count">The number of bytes written to.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer and calls <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> with the length of the source buffer.
            </summary>
            <param name="source">The buffer to copy in.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Ensure(System.Int32)">
            <summary>
            Acquires a new buffer if necessary to ensure that some given number of bytes can be written to a single buffer.
            </summary>
            <param name="count">The number of bytes that must be allocated in a single buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.TryGetUncommittedSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Gets the span to the bytes written if they were never committed to the underlying buffer writer.
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:MessagePack.BufferWriter.EnsureMore(System.Int32)">
            <summary>
            Gets a fresh span to write to, with an optional minimum size.
            </summary>
            <param name="count">The minimum size for the next requested buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.WriteMultiBuffer(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer, potentially across multiple buffers from the underlying writer.
            </summary>
            <param name="source">The buffer to copy into this writer.</param>
        </member>
        <member name="T:MessagePack.SequencePool">
            <summary>
            A thread-safe, alloc-free reusable object pool.
            </summary>
        </member>
        <member name="F:MessagePack.SequencePool.Shared">
            <summary>
            A thread-safe pool of reusable <see cref="T:Nerdbank.Streams.Sequence`1"/> objects.
            </summary>
            <remarks>
            We use a <see cref="F:MessagePack.SequencePool.maxSize"/> that allows every processor to be involved in messagepack serialization concurrently,
            plus one nested serialization per processor (since LZ4 and sometimes other nested serializations may exist).
            </remarks>
        </member>
        <member name="F:MessagePack.SequencePool.MinimumSpanLength">
            <summary>
            The value to use for <see cref="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength"/>.
            </summary>
            <remarks>
            Individual users that want a different value for this can modify the setting on the rented <see cref="T:Nerdbank.Streams.Sequence`1"/>
            or by supplying their own <see cref="T:System.Buffers.IBufferWriter`1" />.
            </remarks>
            <devremarks>
            We use 32KB so that when LZ4Codec.MaximumOutputLength is used on this length it does not require a
            buffer that would require the Large Object Heap.
            </devremarks>
        </member>
        <member name="F:MessagePack.SequencePool.arrayPool">
            <summary>
            The array pool which we share with all <see cref="T:Nerdbank.Streams.Sequence`1"/> objects created by this <see cref="T:MessagePack.SequencePool"/> instance.
            </summary>
            <devremarks>
            We allow 100 arrays to be shared (instead of the default 50) and reduce the max array length from the default 1MB to something more reasonable for our expected use.
            </devremarks>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <param name="maxSize">The maximum size to allow the pool to grow.</param>
        </member>
        <member name="M:MessagePack.SequencePool.Rent">
            <summary>
            Gets an instance of <see cref="T:Nerdbank.Streams.Sequence`1"/>
            This is taken from the recycled pool if one is available; otherwise a new one is created.
            </summary>
            <returns>The rental tracker that provides access to the object as well as a means to return it.</returns>
        </member>
        <member name="P:MessagePack.SequencePool.Rental.Value">
            <summary>
            Gets the recyclable object.
            </summary>
        </member>
        <member name="M:MessagePack.SequencePool.Rental.Dispose">
            <summary>
            Returns the recyclable object to the pool.
            </summary>
            <remarks>
            The instance is cleaned first, if a clean delegate was provided.
            It is dropped instead of being returned to the pool if the pool is already at its maximum size.
            </remarks>
        </member>
        <member name="T:MessagePack.Utilities">
            <summary>
            Internal utilities and extension methods for various external types.
            </summary>
        </member>
        <member name="F:MessagePack.Utilities.IsMono">
            <summary>
            A value indicating whether we're running on mono.
            </summary>
        </member>
        <member name="F:System.Buffers.SequenceReader`1.usingSequence">
            <summary>
            A value indicating whether we're using <see cref="F:System.Buffers.SequenceReader`1.sequence"/> (as opposed to <see cref="F:System.Buffers.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:System.Buffers.SequenceReader`1.sequence">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:System.Buffers.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:System.Buffers.SequenceReader`1.currentPosition">
            <summary>
            The position at the start of the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:System.Buffers.SequenceReader`1.nextPosition">
            <summary>
            The position at the end of the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:System.Buffers.SequenceReader`1.memory">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:System.Buffers.SequenceReader`1.sequence"/>.
            </summary>
        </member>
        <member name="F:System.Buffers.SequenceReader`1.moreData">
            <summary>
            A value indicating whether there is unread data remaining.
            </summary>
        </member>
        <member name="F:System.Buffers.SequenceReader`1.length">
            <summary>
            The total number of elements in the sequence.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Buffers.SequenceReader`1"/> struct
            over the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Buffers.SequenceReader`1"/> struct
            over the given <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.End">
            <summary>
            Gets a value indicating whether there is no more data in the <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Sequence">
            <summary>
            Gets the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/> for the reader.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Position">
            <summary>
            Gets the current position in the <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
            <summary>
            Gets the current segment in the <see cref="P:System.Buffers.SequenceReader`1.Sequence"/> as a span.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
            <summary>
            Gets the index in the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
            <summary>
            Gets the unread portion of the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Consumed">
            <summary>
            Gets the total number of <typeparamref name="T"/>'s processed by the reader.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Remaining">
            <summary>
            Gets remaining <typeparamref name="T"/>'s in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Length">
            <summary>
            Gets count of <typeparamref name="T"/> in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
            <summary>
            Peeks at the next value without advancing the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
            <summary>
            Read the next value and advance the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
            <summary>
            Move the reader back the specified number of items.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.GetNextSpan">
            <summary>
            Get the next segment with available data, if any.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvanceCurrentSpan(System.Int64)">
            <summary>
            Unchecked helper to avoid unnecessary checks where you know count is valid.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvanceWithinSpan(System.Int64)">
            <summary>
            Only call this helper if you know that you are advancing in the current span
            with valid count and there is no need to fetch the next one.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryAdvance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items
            if there are enough elements remaining in the sequence.
            </summary>
            <returns><c>true</c> if there were enough elements to advance; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies data from the current <see cref="P:System.Buffers.SequenceReader`1.Position"/> to the given <paramref name="destination"/> span.
            </summary>
            <param name="destination">Destination to copy to.</param>
            <returns>True if there is enough data to copy to the <paramref name="destination"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
            <summary>
            Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
            structs- see remarks for full details.
            </summary>
            <remarks>
            IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of its members to
            behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
            overloads such as <see cref="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int16@)"/>.
            </remarks>
            <returns>
            True if successful. <paramref name="value"/> will be default if failed (due to lack of space).
            </returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryRead(System.Buffers.SequenceReader{System.Byte}@,System.SByte@)">
            <summary>
            Reads an <see cref="T:System.SByte"/> from the next position in the sequence.
            </summary>
            <param name="reader">The reader to read from.</param>
            <param name="value">Receives the value read.</param>
            <returns><c>true</c> if there was another byte in the sequence; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int16@)">
            <summary>
            Reads an <see cref="T:System.Int16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.UInt16@)">
            <summary>
            Reads an <see cref="T:System.UInt16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt16"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int32@)">
            <summary>
            Reads an <see cref="T:System.Int32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.UInt32@)">
            <summary>
            Reads an <see cref="T:System.UInt32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt32"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int64@)">
            <summary>
            Reads an <see cref="T:System.Int64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.UInt64@)">
            <summary>
            Reads an <see cref="T:System.UInt64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt64"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Single@)">
            <summary>
            Reads a <see cref="T:System.Single"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Single"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Double@)">
            <summary>
            Reads a <see cref="T:System.Double"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Double"/>.</returns>
        </member>
        <member name="T:Nerdbank.Streams.Sequence`1">
            <summary>
            Manages a sequence of elements, readily castable as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <typeparam name="T">The type of element stored by the sequence.</typeparam>
            <remarks>
            Instance members are not thread-safe.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class
            that uses a private <see cref="T:System.Buffers.ArrayPool`1"/> for recycling arrays.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.MemoryPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="memoryPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="arrayPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength">
            <summary>
            Gets or sets the minimum length for any array allocated as a segment in the sequence.
            Any non-positive value allows the pool to determine the length of the array.
            </summary>
            <value>The default value is 0.</value>
            <remarks>
            <para>
            Each time <see cref="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)"/> or <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/> is called,
            previously allocated memory is used if it is large enough to satisfy the length demand.
            If new memory must be allocated, the argument to one of these methods typically dictate
            the length of array to allocate. When the caller uses very small values (just enough for its immediate need)
            but the high level scenario can predict that a large amount of memory will be ultimately required,
            it can be advisable to set this property to a value such that just a few larger arrays are allocated
            instead of many small ones.
            </para>
            <para>
            The <see cref="T:System.Buffers.MemoryPool`1"/> in use may itself have a minimum array length as well,
            in which case the higher of the two minimums dictate the minimum array size that will be allocated.
            </para>
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.AsReadOnlySequence">
            <summary>
            Gets this sequence expressed as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <returns>A read only sequence representing the data in this object.</returns>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.Length">
            <summary>
            Gets the length of the sequence.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.DebuggerDisplay">
            <summary>
            Gets the value to display in a debugger datatip.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.op_Implicit(Nerdbank.Streams.Sequence{`0})~System.Buffers.ReadOnlySequence{`0}">
            <summary>
            Expresses this sequence as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="sequence">The sequence to convert.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)">
            <summary>
            Removes all elements from the sequence from its beginning to the specified position,
            considering that data to have been fully processed.
            </summary>
            <param name="position">
            The position of the first element that has not yet been processed.
            This is typically <see cref="P:System.Buffers.ReadOnlySequence`1.End"/> after reading all elements from that instance.
            </param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)">
            <summary>
            Advances the sequence to include the specified number of elements initialized into memory
            returned by a prior call to <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/>.
            </summary>
            <param name="count">The number of elements written into memory.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Dispose">
            <summary>
            Clears the entire sequence, recycles associated memory into pools,
            and resets this instance for reuse.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Reset">
            <summary>
            Clears the entire sequence and recycles associated memory into pools.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.IsValueTypeElement">
            <summary>
            A value indicating whether the element is a value type.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array">
            <summary>
            Gets the backing array, when using an <see cref="T:System.Buffers.ArrayPool`1"/> instead of a <see cref="T:System.Buffers.MemoryPool`1"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Start">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data starts.
            </summary>
            <remarks>This may be nonzero as a result of calling <see cref="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)"/>.</remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data ends.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingMemory">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingSpan">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner">
            <summary>
            Gets the tracker for the underlying array for this segment, which can be used to recycle the array when we're disposed of.
            Will be <c>null</c> if using an array pool, in which case the memory is held by <see cref="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.AvailableMemory">
            <summary>
            Gets the full memory owned by the <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length">
            <summary>
            Gets the number of elements that are committed in this segment.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.WritableBytes">
            <summary>
            Gets the amount of writable bytes in this segment.
            It is the amount of bytes between <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length"/> and <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Next">
            <summary>
            Gets or sets the next segment in the singly linked list of segments.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(System.Buffers.IMemoryOwner{`0})">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="memoryOwner">The memory and a means to recycle it.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(`0[])">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="array">An array drawn from an <see cref="T:System.Buffers.ArrayPool`1"/>.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.ResetMemory(System.Buffers.ArrayPool{`0})">
            <summary>
            Clears all fields in preparation to recycle this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.SetNext(Nerdbank.Streams.Sequence{`0}.SequenceSegment)">
            <summary>
            Adds a new segment after this one.
            </summary>
            <param name="segment">The next segment in the linked list.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Advance(System.Int32)">
            <summary>
            Commits more elements as written in this segment.
            </summary>
            <param name="count">The number of elements written.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.AdvanceTo(System.Int32)">
            <summary>
            Removes some elements from the start of this segment.
            </summary>
            <param name="offset">The number of elements to ignore from the start of the underlying array.</param>
        </member>
    </members>
</doc>
